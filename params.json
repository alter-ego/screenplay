{"name":"Screenplay","tagline":"Screen transitions, paging and modal layouts for Square's Flow","body":"Screenplay\r\n==========\r\n\r\nScreenplay is a companion library to Square's [Flow](http://corner.squareup.com/2014/01/mortar-and-flow.html). Where Flow provides\r\nthe essential elements for building a View-based navigation flow, Screenplay assembles these into\r\nhigher-level components for building animated screen transitions. The core features that Screenplay\r\nsupports are:\r\n\r\n- **Paged** (full-screen) navigation flows\r\n- **Modal** (pop-up) navigation flows\r\n- **Animated** **transitions** for incoming and outgoing views\r\n- **View** **state** **reattachment** for configuration changes\r\n\r\nDisplaying a screen in Screenplay consists of four discrete phases:\r\n\r\n1. A `Scene` creates the view,\r\n2. Scene `Components` receive callbacks and apply behavior\r\n3. The `Rigger` attaches the scene to the layout\r\n4. A `Transformer` plays animations between the incoming and outgoing scene.\r\n\r\nThese steps are applied by the `Screenplay` object, which implements the `Flow.Listener` interface. The\r\nScreenplay object knows how to reverse these steps when the back button is pressed, and how to\r\nre-attach the screen state after a configuration change (such as rotating the phone from portrait to\r\nlandscape mode).\r\n\r\n###Setting the stage\r\n\r\nApp navigation using Screenplay is very straightforward. Begin by creating a `Screenplay.Director`.\r\nPass this to the `Screenplay` and create a new `Flow`. In order to ensure that the Flow survives\r\nconfiguration changes, these objects should be stored outside of your main Activity. One way to do\r\nthis is by putting them in the Application class:\r\n\r\n```java\r\npublic class SampleApplication extends Application {\r\n\r\n    public final SimpleActivityDirector director = new SimpleActivityDirector();\r\n    public final Screenplay screenplay = new Screenplay(director);\r\n    public final Flow mainFlow = new Flow(Backstack.single(new HomeScreen()), screenplay);\r\n    private Application application;\r\n\r\n    public void onCreate() { application = this; }\r\n\r\n    public static SampleApplication getInstance()   { return application; }\r\n    public static Director getDirector()            { return getInstance().director; }\r\n    public static Screenplay getScreenplay()        { return getInstance().screenplay; }\r\n    public static Flow getMainFlow()                { return getInstance().flow; }\r\n}\r\n```\r\n\r\n*(alternatively, use a dependency injection library such as [Dagger](http://square.github.io/dagger/))*\r\n\r\nThen, in the onCreate() method of your main Activity, bind your `Director` and call\r\n`Screenplay.enter(flow)` to initialize the screen state:\r\n\r\n```java\r\npublic class MainActivity extends Activity {\r\n    public void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n\r\n        setContentView(R.id.main);\r\n        RelativeLayout container = (RelativeLayout) activity.findViewById(R.id.main);\r\n\r\n        Director director = SampleApplication.getDirector();\r\n        Flow flow = SampleApplication.getMainFlow();\r\n        Screenplay screenplay = SampleApplication.getScreenplay();\r\n\r\n        director.bind(this, container);\r\n        screenplay.enter(flow);\r\n    }\r\n}\r\n```\r\n\r\nCalling `enter` will initialize the Flow to the current screen, and also re-attach any Views that\r\nwere detached during configuration changes.\r\n\r\nOnce you've created your Flow, navigation is the same as in any other Flow application:\r\n\r\n```java\r\n    flow.goTo(new DetailScene()); // animates forward to the DetailScene\r\n    flow.goUp();                  // animate back to the parent of the scene\r\n    flow.goBack();                // animate back to the previous scene\r\n```\r\n\r\nOne final detail: when the Activity is destroyed, is important to drop references to it to\r\navoid memory leaks. Using the `SimpleActivityDirector`, you can drop the old Activity reference by\r\ncalling `unbind()` in your Activity's `onDestroy()` callback.\r\n\r\n```java\r\n    @Override\r\n    public void onDestroy() {\r\n        super.onDestroy()\r\n        if (isFinishing()) {\r\n            director.unbind()\r\n        }\r\n    }\r\n```\r\n\r\nIf you're using `MortarActivityDirector`, call `dropView()` instead. In either case, the Director\r\nshould be rebound in `onCreate()`.\r\n\r\n###Anatomy of a Scene\r\n\r\nThe building block of a Screenplay app is a `Scene`. The Scene knows how to do\r\nonly a few things by itself: create a View (`Scene.setUp`), destroy a View (`Scene.tearDown`) and get\r\nthe current view (`Scene.getView`).\r\n\r\nThe standard scene implementation uses Flow's [Layouts.createView()](https://github.com/square/flow/blob/master/flow/src/main/java/flow/Layouts.java)\r\nto set up the scene. You can pass a list of `Component`s to the scene constructor, which can be used\r\nto apply behaviors after the scene is set up and before it is torn down:\r\n\r\n```java\r\n@Layout(R.layout.dialog_scene)\r\npublic class DialogScene extends StandardScene {\r\n    public DialogScene(DrawerLockingComponent component) {\r\n        super(component);\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npublic class DrawerLockingComponent implements Scene.Component {\r\n\r\n    private final DrawerPresenter drawer;\r\n\r\n    public DrawerLockingComponent(DrawerPresenter drawer) {\r\n        this.drawer = drawer;\r\n    }\r\n\r\n    @Override\r\n    public void afterSetUp(Context context, Scene scene) {\r\n        drawer.setLocked(true);\r\n    }\r\n\r\n    @Override\r\n    public void beforeTearDown(Context context, Scene scene) {\r\n        drawer.setLocked(false);\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n###Riggers and Transformers\r\n\r\nIn a Screenplay app, when the application calls `Flow.goTo()` or `Flow.goBack()`, the type of layout\r\nchange that is applied depends on the type of ``Screen.Rigger`` that is associated with the next\r\nscene. Screenplay provides two concrete `Rigger` implementations.\r\n\r\n- The `PageRigger` manages full-screen layout changes. After all animations complete, the PageRigger\r\nremoves the previous screen from its parent layout.\r\n- The `ModalRigger` manages partial-screen layout changes. It does not remove the previous Scene\r\nfrom the layout, allowing you to layer Scenes on top of each other. This is useful for creating\r\ndialogs, drawers and multi-pane layouts.\r\n\r\nBoth the `PagedRigger` and the `ModalRigger` remove the Scene at the top of the stack when `Flow.goBack()` is called.\r\n\r\n```java\r\n@Layout(R.layout.navigation_drawer)\r\npublic class NavigationDrawerScene extends StandardScene {\r\n\r\n    private final ModalRigger rigger;\r\n    private final NavigationDrawerTransformer transformer;\r\n\r\n    public NavigationDrawerScene() {\r\n        this.rigger = new ModalRigger();\r\n        this.transformer = new NavigationDrawerTransformer();\r\n    }\r\n\r\n    @Override\r\n    public Rigger getRigger() {\r\n        return rigger;\r\n    }\r\n\r\n    @Override\r\n    public Transformer getTransformer() {\r\n        return transition;\r\n    }\r\n}\r\n```\r\n\r\nA `Transformer` is responsible for applying animations between Stages. The `Transformer` receives\r\na `SceneCut` object, which contains the data that the `Transformer` needs to create animations,\r\nincluding the `Flow.Direction`, and the next (incoming) and previous (outgoing) stages.\r\n\r\n```java\r\n@Singleton\r\npublic class HorizontalSlideTransformer extends TweenTransformer {\r\n\r\n    private static final Params params = new Params();\r\n\r\n    static {\r\n        params.forwardIn    = R.anim.slide_in_right;\r\n        params.backIn       = R.anim.slide_in_left;\r\n        params.backOut      = R.anim.slide_out_right;\r\n        params.forwardOut   = R.anim.slide_out_left;\r\n    }\r\n\r\n    public HorizontalSlideTransformer(Application context) {\r\n        super(context, params);\r\n    }\r\n}\r\n```\r\n\r\nScreenplay provides two `Transformer` implementations to extend from: `TweenTransformer`\r\nand `AnimatorTransformer`. TweenTransformer uses the [Animation](http://developer.android.com/reference/android/view/animation/Animation.html) class, while\r\nthe AnimatorTransformer uses the [Animator](http://developer.android.com/reference/android/animation/Animator.html) class.\r\n\r\n###Odds and ends\r\n\r\nThe `Screenplay` object also exposes a `getScreenState()` method, which returns a `FlowState` object. This is\r\nuseful for preventing multiple button presses while two Scenes are in transition:\r\n\r\n```java\r\n    @Override\r\n    public boolean onOptionsItemSelected(MenuItem item) {\r\n        // Ignore menu click if stage is transitioning\r\n        if (screenplay.getScreenState() == SceneState.TRANSITIONING) return true;\r\n\r\n        switch (item.getItemId()) {\r\n            ...\r\n        }\r\n    }\r\n```\r\n\r\n###Mortar support\r\n\r\nScreenplay provides support for (but does not require) Square's [Mortar](http://corner.squareup.com/2014/01/mortar-and-flow.html).\r\nIt provides two classes, a [MortarActivityDirector](https://github.com/weefbellington/screenplay/blob/master/library/src/main/java/com/davidstemmer/screenplay/MortarActivityDirector.java)\r\nand a [ScopedScene](https://github.com/weefbellington/screenplay/blob/master/library/src/main/java/com/davidstemmer/screenplay/scene/ScopedScene.java),\r\nwhich are designed to support applications powered by Mortar.\r\n\r\n###That's, all folks!\r\n\r\nScreenplay is designed to be simple and extensible. It works well in concert with its friends\r\nDagger, Flow, Butterknife and Mortar. You can see them all together in the [sample project](https://github.com/weefbellington/screenplay/tree/master/sample/src/main).\r\n\r\nMany thanks to the team at Square for their support of the open-source community, without which this project wouldn't be\r\npossible.\r\n\r\nMaven artifact is coming soon!","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}